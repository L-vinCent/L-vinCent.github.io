<!doctype html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta name="google-site-verification" content="m3UI4lcUPqpZrsd0hAa_xv7QZH4x70BTPJzUp-HHnyo" />
<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />














  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="OC," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description" content="今天在整理笔记的时候发现的一篇以前摘下来的博客，目前看到的对RunLoop剖析最棒的一篇，吃透这篇文章，一定收获巨大。如果你还在面试，觉得RunLoop是个拦路虎，那么别犹豫了，花时间看完然后慢慢理解，面试会更有信心  时间过的比较久，忘了博主和具体的出处了，有知道的请告知一下。  RunLoop 的概念一般来讲，一个线程一次只能执行一个任务，执行完成后线程就会退出。如果我们需要一个机制，让线程能">
<meta name="keywords" content="OC">
<meta property="og:type" content="article">
<meta property="og:title" content="深入理解RunLoop">
<meta property="og:url" content="https://l-vincent.github.io/2017/05/12/Runloop/index.html">
<meta property="og:site_name" content="L-vinCent&#39;s Blog">
<meta property="og:description" content="今天在整理笔记的时候发现的一篇以前摘下来的博客，目前看到的对RunLoop剖析最棒的一篇，吃透这篇文章，一定收获巨大。如果你还在面试，觉得RunLoop是个拦路虎，那么别犹豫了，花时间看完然后慢慢理解，面试会更有信心  时间过的比较久，忘了博主和具体的出处了，有知道的请告知一下。  RunLoop 的概念一般来讲，一个线程一次只能执行一个任务，执行完成后线程就会退出。如果我们需要一个机制，让线程能">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/904629-4872a8e485b2d08e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/904629-d7d5146313a4e1c7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/904629-aefecc5007b9e4f6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/904629-ff633a9e5ec869b4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/904629-ce4c380a8b52460b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:updated_time" content="2017-06-12T09:45:41.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="深入理解RunLoop">
<meta name="twitter:description" content="今天在整理笔记的时候发现的一篇以前摘下来的博客，目前看到的对RunLoop剖析最棒的一篇，吃透这篇文章，一定收获巨大。如果你还在面试，觉得RunLoop是个拦路虎，那么别犹豫了，花时间看完然后慢慢理解，面试会更有信心  时间过的比较久，忘了博主和具体的出处了，有知道的请告知一下。  RunLoop 的概念一般来讲，一个线程一次只能执行一个任务，执行完成后线程就会退出。如果我们需要一个机制，让线程能">
<meta name="twitter:image" content="http://upload-images.jianshu.io/upload_images/904629-4872a8e485b2d08e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://l-vincent.github.io/2017/05/12/Runloop/"/>





  <title>深入理解RunLoop | L-vinCent's Blog</title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  















  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">L-vinCent's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">“努力的学习”意味着，要常常去处理那些刚好在你能力极限上的问题</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            目录
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://l-vincent.github.io/2017/05/12/Runloop/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Pan'V">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="L-vinCent's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">深入理解RunLoop</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-12T17:37:45+08:00">
                2017-05-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Objective-C/" itemprop="url" rel="index">
                    <span itemprop="name">Objective-C</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/05/12/Runloop/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/05/12/Runloop/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>今天在整理笔记的时候发现的一篇以前摘下来的博客，目前看到的对RunLoop剖析最棒的一篇，吃透这篇文章，一定收获巨大。<br>如果你还在面试，觉得RunLoop是个拦路虎，那么别犹豫了，花时间看完然后慢慢理解，面试会更有信心</p>
<hr>
<p>时间过的比较久，忘了博主和具体的出处了，有知道的请告知一下。</p>
<hr>
<h2 id="RunLoop-的概念"><a href="#RunLoop-的概念" class="headerlink" title="RunLoop 的概念"></a>RunLoop 的概念</h2><p>一般来讲，一个线程一次只能执行一个任务，执行完成后线程就会退出。如果我们需要一个机制，让线程能随时处理事件但并不退出，通常的代码逻辑是这样的：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">loop</span></span>() &#123;</div><div class="line">initialize();</div><div class="line"><span class="keyword">do</span> &#123;</div><div class="line">var message = get_next_message();</div><div class="line">process_message(message);</div><div class="line">&#125; <span class="keyword">while</span> (message != quit);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这种模型通常被称作 <a href="http://en.wikipedia.org/wiki/Event_loop" target="_blank" rel="external">Event Loop</a>。 Event Loop 在很多系统和框架里都有实现，比如 Node.js 的事件处理，比如 Windows 程序的消息循环，再比如 OSX/iOS 里的 RunLoop。实现这种模型的关键点在于：如何管理事件/消息，如何让线程在没有处理消息时休眠以避免资源占用、在有消息到来时立刻被唤醒。<br>所以，RunLoop 实际上就是一个对象，这个对象管理了其需要处理的事件和消息，并提供了一个入口函数来执行上面 Event Loop 的逻辑。线程执行了这个函数后，就会一直处于这个函数内部 “接受消息-&gt;等待-&gt;处理” 的循环中，直到这个循环结束（比如传入 quit 的消息），函数返回。<br>OSX/iOS 系统中，提供了两个这样的对象：NSRunLoop 和 CFRunLoopRef。<br>CFRunLoopRef 是在 CoreFoundation 框架内的，它提供了纯 C 函数的 API，所有这些 API 都是线程安全的。<br>NSRunLoop 是基于 CFRunLoopRef 的封装，提供了面向对象的 API，但是这些 API 不是线程安全的。<br>CFRunLoopRef 的代码是<a href="http://opensource.apple.com/source/CF/CF-855.17/CFRunLoop.c" target="_blank" rel="external">开源</a>的，你可以在这里 <a href="http://opensource.apple.com/tarballs/CF/CF-855.17.tar.gz" target="_blank" rel="external">http://opensource.apple.com/tarballs/CF/CF-855.17.tar.gz</a> 下载到整个 CoreFoundation 的源码。为了方便跟踪和查看，你可以新建一个 Xcode 工程，把这堆源码拖进去看。</p>
<h2 id="RunLoop-与线程的关系"><a href="#RunLoop-与线程的关系" class="headerlink" title="RunLoop 与线程的关系"></a>RunLoop 与线程的关系</h2><p>首先，iOS 开发中能遇到两个线程对象: pthread_t 和 NSThread。过去苹果有份<a href="http://www.fenestrated.net/~macman/mirrors/Apple%20Technotes%20(As%20of%202002" target="_blank" rel="external">文档</a>/tn/tn2028.html)标明了 NSThread 只是 pthread_t 的封装，但那份文档已经失效了，现在它们也有可能都是直接包装自最底层的 mach thread。苹果并没有提供这两个对象相互转换的接口，但不管怎么样，可以肯定的是 pthread_t 和 NSThread 是一一对应的。比如，你可以通过 pthread_main_np() 或 [NSThread mainThread] 来获取主线程；也可以通过 pthread_self() 或 [NSThread currentThread] 来获取当前线程。CFRunLoop 是基于 pthread 来管理的。<br>苹果不允许直接创建 RunLoop，它只提供了两个自动获取的函数：CFRunLoopGetMain() 和 CFRunLoopGetCurrent()。 这两个函数内部的逻辑大概是下面这样:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">/// 全局的Dictionary，key 是 pthread_t， value 是 CFRunLoopRef</div><div class="line">static CFMutableDictionaryRef loopsDic;</div><div class="line">/// 访问 loopsDic 时的锁</div><div class="line">static CFSpinLock_t loopsLock;</div><div class="line"></div><div class="line">/// 获取一个 pthread 对应的 RunLoop。</div><div class="line">CFRunLoopRef _CFRunLoopGet(pthread_t thread) &#123;</div><div class="line">OSSpinLockLock(&amp;loopsLock);</div><div class="line"></div><div class="line"><span class="keyword">if</span> (!loopsDic) &#123;</div><div class="line">// 第一次进入时，初始化全局Dic，并先为主线程创建一个 RunLoop。</div><div class="line">loopsDic = CFDictionaryCreateMutable();</div><div class="line">CFRunLoopRef mainLoop = _CFRunLoopCreate();</div><div class="line">CFDictionarySetValue(loopsDic, pthread_main_thread_np(), mainLoop);</div><div class="line">&#125;</div><div class="line"></div><div class="line">/// 直接从 Dictionary 里获取。</div><div class="line">CFRunLoopRef loop = CFDictionaryGetValue(loopsDic, thread));</div><div class="line"></div><div class="line"><span class="keyword">if</span> (!loop) &#123;</div><div class="line">/// 取不到时，创建一个</div><div class="line">loop = _CFRunLoopCreate();</div><div class="line">CFDictionarySetValue(loopsDic, thread, loop);</div><div class="line">/// 注册一个回调，当线程销毁时，顺便也销毁其对应的 RunLoop。</div><div class="line">_CFSetTSD(..., thread, loop, __CFFinalizeRunLoop);</div><div class="line">&#125;</div><div class="line"></div><div class="line">OSSpinLockUnLock(&amp;loopsLock);</div><div class="line"><span class="built_in">return</span> loop;</div><div class="line">&#125;</div><div class="line"></div><div class="line">CFRunLoopRef <span class="function"><span class="title">CFRunLoopGetMain</span></span>() &#123;</div><div class="line"><span class="built_in">return</span> _CFRunLoopGet(pthread_main_thread_np());</div><div class="line">&#125;</div><div class="line"></div><div class="line">CFRunLoopRef <span class="function"><span class="title">CFRunLoopGetCurrent</span></span>() &#123;</div><div class="line"><span class="built_in">return</span> _CFRunLoopGet(pthread_self());</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>从上面的代码可以看出，线程和 RunLoop 之间是一一对应的，其关系是保存在一个全局的 Dictionary 里。线程刚创建时并没有 RunLoop，如果你不主动获取，那它一直都不会有。RunLoop 的创建是发生在第一次获取时，RunLoop 的销毁是发生在线程结束时。你只能在一个线程的内部获取其 RunLoop（主线程除外）。</p>
<h2 id="RunLoop-对外的接口"><a href="#RunLoop-对外的接口" class="headerlink" title="RunLoop 对外的接口"></a>RunLoop 对外的接口</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">在 CoreFoundation 里面关于 RunLoop 有5个类:</div><div class="line"></div><div class="line">CFRunLoopRef</div><div class="line"></div><div class="line">CFRunLoopModeRef</div><div class="line"></div><div class="line">CFRunLoopSourceRef</div><div class="line"></div><div class="line">CFRunLoopTimerRef</div><div class="line"></div><div class="line">CFRunLoopObserverRef</div></pre></td></tr></table></figure>
<p>其中 CFRunLoopModeRef 类并没有对外暴露，只是通过 CFRunLoopRef 的接口进行了封装。他们的关系如下:</p>
<p><img src="http://upload-images.jianshu.io/upload_images/904629-4872a8e485b2d08e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="1128643-20170322095809580-1878876210.png"></p>
<p>一个 RunLoop 包含若干个 Mode，每个 Mode 又包含若干个 Source/Timer/Observer。每次调用 RunLoop 的主函数时，只能指定其中一个 Mode，这个Mode被称作 CurrentMode。如果需要切换 Mode，只能退出 Loop，再重新指定一个 Mode 进入。这样做主要是为了分隔开不同组的 Source/Timer/Observer，让其互不影响。</p>
<p>CFRunLoopSourceRef 是事件产生的地方。Source有两个版本：Source0 和 Source1。</p>
<ul>
<li><p>Source0 只包含了一个回调（函数指针），它并不能主动触发事件。使用时，你需要先调用 CFRunLoopSourceSignal(source)，将这个 Source 标记为待处理，然后手动调用 CFRunLoopWakeUp(runloop) 来唤醒 RunLoop，让其处理这个事件。</p>
</li>
<li><p>Source1 包含了一个 mach_port 和一个回调（函数指针），被用于通过内核和其他线程相互发送消息。这种 Source 能主动唤醒 RunLoop 的线程，其原理在下面会讲到。<br>CFRunLoopTimerRef 是基于时间的触发器，它和 NSTimer 是toll-free bridged 的，可以混用。其包含一个时间长度和一个回调（函数指针）。当其加入到 RunLoop 时，RunLoop会注册对应的时间点，当时间点到时，RunLoop会被唤醒以执行那个回调。</p>
</li>
</ul>
<p>CFRunLoopObserverRef 是观察者，每个 Observer 都包含了一个回调（函数指针），当 RunLoop 的状态发生变化时，观察者就能通过回调接受到这个变化。可以观测的时间点有以下几个：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123;</div><div class="line">kCFRunLoopEntry         = (1UL &lt;&lt; 0), // 即将进入Loop</div><div class="line">kCFRunLoopBeforeTimers  = (1UL &lt;&lt; 1), // 即将处理 Timer</div><div class="line">kCFRunLoopBeforeSources = (1UL &lt;&lt; 2), // 即将处理 Source</div><div class="line">kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5), // 即将进入休眠</div><div class="line">kCFRunLoopAfterWaiting  = (1UL &lt;&lt; 6), // 刚从休眠中唤醒</div><div class="line">kCFRunLoopExit          = (1UL &lt;&lt; 7), // 即将退出Loop</div><div class="line">&#125;;</div><div class="line">``` </div><div class="line">上面的 Source/Timer/Observer 被统称为 mode item，一个 item 可以被同时加入多个 mode。但一个 item 被重复加入同一个 mode 时是不会有效果的。如果一个 mode 中一个 item 都没有，则 RunLoop 会直接退出，不进入循环。</div><div class="line"></div><div class="line">## RunLoop 的 Mode</div><div class="line"></div><div class="line">CFRunLoopMode 和 CFRunLoop 的结构大致如下：</div><div class="line">``` bash</div><div class="line">struct __CFRunLoopMode &#123;   </div><div class="line">CFStringRef _name;            // Mode Name, 例如 @&quot;kCFRunLoopDefaultMode&quot;   </div><div class="line">CFMutableSetRef _sources0;    // Set   </div><div class="line">CFMutableSetRef _sources1;    // Set  </div><div class="line">CFMutableArrayRef _observers; // Array     </div><div class="line">　CFMutableArrayRef _timers;    // Array     ...</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">struct __CFRunLoop &#123;   </div><div class="line">CFMutableSetRef _commonModes;     // Set   </div><div class="line">CFMutableSetRef _commonModeItems; // Set   </div><div class="line">CFRunLoopModeRef _currentMode;    // Current Runloop Mode   </div><div class="line">CFMutableSetRef _modes;           // Set     ... </div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这里有个概念叫 “CommonModes”：一个 Mode 可以将自己标记为”Common”属性（通过将其 ModeName 添加到 RunLoop 的 “commonModes” 中）。每当 RunLoop 的内容发生变化时，RunLoop 都会自动将 _commonModeItems 里的 Source/Observer/Timer 同步到具有 “Common” 标记的所有Mode里。</p>
<p>应用场景举例：主线程的 RunLoop 里有两个预置的 Mode：kCFRunLoopDefaultMode 和 UITrackingRunLoopMode。这两个 Mode 都已经被标记为”Common”属性。DefaultMode 是 App 平时所处的状态，TrackingRunLoopMode 是追踪 ScrollView 滑动时的状态。当你创建一个 Timer 并加到 DefaultMode 时，Timer 会得到重复回调，但此时滑动一个TableView时，RunLoop 会将 mode 切换为 TrackingRunLoopMode，这时 Timer 就不会被回调，并且也不会影响到滑动操作。</p>
<p>有时你需要一个 Timer，在两个 Mode 中都能得到回调，一种办法就是将这个 Timer 分别加入这两个 Mode。还有一种方式，就是将 Timer 加入到顶层的 RunLoop 的 “commonModeItems” 中。”commonModeItems” 被 RunLoop 自动更新到所有具有”Common”属性的 Mode 里去。</p>
<p>CFRunLoop对外暴露的管理 Mode 接口只有下面2个:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">CFRunLoopAddCommonMode(CFRunLoopRef runloop, CFStringRef modeName);</div><div class="line">CFRunLoopRunInMode(CFStringRef modeName, ...);</div></pre></td></tr></table></figure></p>
<p>Mode 暴露的管理 mode item 的接口有下面几个：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">CFRunLoopAddSource(CFRunLoopRef rl, CFRunLoopSourceRef <span class="built_in">source</span>, CFStringRef modeName);</div><div class="line">CFRunLoopAddObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFStringRef modeName);</div><div class="line">CFRunLoopAddTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFStringRef mode);</div><div class="line">CFRunLoopRemoveSource(CFRunLoopRef rl, CFRunLoopSourceRef <span class="built_in">source</span>, CFStringRef modeName);</div><div class="line">CFRunLoopRemoveObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFStringRef modeName);</div><div class="line">CFRunLoopRemoveTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFStringRef mode);</div></pre></td></tr></table></figure>
<p>你只能通过 mode name 来操作内部的 mode，当你传入一个新的 mode name 但 RunLoop 内部没有对应 mode 时，RunLoop会自动帮你创建对应的 CFRunLoopModeRef。对于一个 RunLoop 来说，其内部的 mode 只能增加不能删除。</p>
<p>苹果公开提供的 Mode 有两个：kCFRunLoopDefaultMode (NSDefaultRunLoopMode) 和 UITrackingRunLoopMode，你可以用这两个 Mode Name 来操作其对应的 Mode。</p>
<p>同时苹果还提供了一个操作 Common 标记的字符串：kCFRunLoopCommonModes (NSRunLoopCommonModes)，你可以用这个字符串来操作 Common Items，或标记一个 Mode 为 “Common”。使用时注意区分这个字符串和其他 mode name。</p>
<h2 id="RunLoop-的内部逻辑"><a href="#RunLoop-的内部逻辑" class="headerlink" title="RunLoop 的内部逻辑"></a>RunLoop 的内部逻辑</h2><p>根据苹果在文档里的说明，RunLoop 内部的逻辑大致如下:</p>
<p><img src="http://upload-images.jianshu.io/upload_images/904629-d7d5146313a4e1c7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="1128643-20170322100346736-2080747729.png"></p>
<p>其内部代码整理如下 （太长了不想看可以直接跳过去，后面会有说明）：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div></pre></td><td class="code"><pre><div class="line">/// 用DefaultMode启动</div><div class="line">void CFRunLoopRun(void) &#123;</div><div class="line">CFRunLoopRunSpecific(CFRunLoopGetCurrent(), kCFRunLoopDefaultMode, 1.0e10, <span class="literal">false</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">/// 用指定的Mode启动，允许设置RunLoop超时时间</div><div class="line">int CFRunLoopRunInMode(CFStringRef modeName, CFTimeInterval seconds, Boolean stopAfterHandle) &#123;</div><div class="line"><span class="built_in">return</span> CFRunLoopRunSpecific(CFRunLoopGetCurrent(), modeName, seconds, returnAfterSourceHandled);</div><div class="line">&#125;</div><div class="line"></div><div class="line">/// RunLoop的实现</div><div class="line">int CFRunLoopRunSpecific(runloop, modeName, seconds, stopAfterHandle) &#123;</div><div class="line"></div><div class="line">/// 首先根据modeName找到对应mode</div><div class="line">CFRunLoopModeRef currentMode = __CFRunLoopFindMode(runloop, modeName, <span class="literal">false</span>);</div><div class="line">/// 如果mode里没有<span class="built_in">source</span>/timer/observer, 直接返回。</div><div class="line"><span class="keyword">if</span> (__CFRunLoopModeIsEmpty(currentMode)) <span class="built_in">return</span>;</div><div class="line"></div><div class="line">/// 1. 通知 Observers: RunLoop 即将进入 loop。</div><div class="line">__CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopEntry);</div><div class="line"></div><div class="line">/// 内部函数，进入loop</div><div class="line">__CFRunLoopRun(runloop, currentMode, seconds, returnAfterSourceHandled) &#123;</div><div class="line"></div><div class="line">Boolean sourceHandledThisLoop = NO;</div><div class="line">int retVal = 0;</div><div class="line"><span class="keyword">do</span> &#123;</div><div class="line"></div><div class="line">/// 2. 通知 Observers: RunLoop 即将触发 Timer 回调。</div><div class="line">__CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeTimers);</div><div class="line">/// 3. 通知 Observers: RunLoop 即将触发 Source0 (非port) 回调。</div><div class="line">__CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeSources);</div><div class="line">/// 执行被加入的block</div><div class="line">__CFRunLoopDoBlocks(runloop, currentMode);</div><div class="line"></div><div class="line">/// 4. RunLoop 触发 Source0 (非port) 回调。</div><div class="line">sourceHandledThisLoop = __CFRunLoopDoSources0(runloop, currentMode, stopAfterHandle);</div><div class="line">/// 执行被加入的block</div><div class="line">__CFRunLoopDoBlocks(runloop, currentMode);</div><div class="line"></div><div class="line">/// 5. 如果有 Source1 (基于port) 处于 ready 状态，直接处理这个 Source1 然后跳转去处理消息。</div><div class="line"><span class="keyword">if</span> (__Source0DidDispatchPortLastTime) &#123;</div><div class="line">Boolean hasMsg = __CFRunLoopServiceMachPort(dispatchPort, &amp;msg)</div><div class="line"><span class="keyword">if</span> (hasMsg) goto handle_msg;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/// 通知 Observers: RunLoop 的线程即将进入休眠(sleep)。</div><div class="line"><span class="keyword">if</span> (!sourceHandledThisLoop) &#123;</div><div class="line">__CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeWaiting);</div><div class="line">&#125;</div><div class="line"></div><div class="line">/// 7. 调用 mach_msg 等待接受 mach_port 的消息。线程将进入休眠, 直到被下面某一个事件唤醒。</div><div class="line">/// ? 一个基于 port 的Source 的事件。</div><div class="line">/// ? 一个 Timer 到时间了</div><div class="line">/// ? RunLoop 自身的超时时间到了</div><div class="line">/// ? 被其他什么调用者手动唤醒</div><div class="line">__CFRunLoopServiceMachPort(waitSet, &amp;msg, sizeof(msg_buffer), &amp;livePort) &#123;</div><div class="line">mach_msg(msg, MACH_RCV_MSG, port); // thread <span class="built_in">wait</span> <span class="keyword">for</span> receive msg</div><div class="line">&#125;</div><div class="line"></div><div class="line">/// 8. 通知 Observers: RunLoop 的线程刚刚被唤醒了。</div><div class="line">__CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopAfterWaiting);</div><div class="line"></div><div class="line">/// 收到消息，处理消息。</div><div class="line">handle_msg:</div><div class="line"></div><div class="line">/// 9.1 如果一个 Timer 到时间了，触发这个Timer的回调。</div><div class="line"><span class="keyword">if</span> (msg_is_timer) &#123;</div><div class="line">__CFRunLoopDoTimers(runloop, currentMode, mach_absolute_time())</div><div class="line">&#125; </div><div class="line"></div><div class="line">/// 9.2 如果有dispatch到main_queue的block，执行block。</div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> (msg_is_dispatch) &#123;</div><div class="line">__CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg);</div><div class="line">&#125; </div><div class="line"></div><div class="line">/// 9.3 如果一个 Source1 (基于port) 发出事件了，处理这个事件</div><div class="line"><span class="keyword">else</span> &#123;</div><div class="line">CFRunLoopSourceRef source1 = __CFRunLoopModeFindSourceForMachPort(runloop, currentMode, livePort);</div><div class="line">sourceHandledThisLoop = __CFRunLoopDoSource1(runloop, currentMode, source1, msg);</div><div class="line"><span class="keyword">if</span> (sourceHandledThisLoop) &#123;</div><div class="line">mach_msg(reply, MACH_SEND_MSG, reply);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/// 执行加入到Loop的block</div><div class="line">__CFRunLoopDoBlocks(runloop, currentMode);</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">if</span> (sourceHandledThisLoop &amp;&amp; stopAfterHandle) &#123;</div><div class="line">/// 进入loop时参数说处理完事件就返回。</div><div class="line">retVal = kCFRunLoopRunHandledSource;</div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (timeout) &#123;</div><div class="line">/// 超出传入参数标记的超时时间了</div><div class="line">retVal = kCFRunLoopRunTimedOut;</div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (__CFRunLoopIsStopped(runloop)) &#123;</div><div class="line">/// 被外部调用者强制停止了</div><div class="line">retVal = kCFRunLoopRunStopped;</div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (__CFRunLoopModeIsEmpty(runloop, currentMode)) &#123;</div><div class="line">/// <span class="built_in">source</span>/timer/observer一个都没有了</div><div class="line">retVal = kCFRunLoopRunFinished;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/// 如果没超时，mode里没空，loop也没被停止，那继续loop。</div><div class="line">&#125; <span class="keyword">while</span> (retVal == 0);</div><div class="line">&#125;</div><div class="line"></div><div class="line">/// 10. 通知 Observers: RunLoop 即将退出。</div><div class="line">__CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看到，实际上 RunLoop 就是这样一个函数，其内部是一个 do-while 循环。当你调用 CFRunLoopRun() 时，线程就会一直停留在这个循环里；直到超时或被手动停止，该函数才会返回。</p>
<h2 id="RunLoop-的底层实现"><a href="#RunLoop-的底层实现" class="headerlink" title="RunLoop 的底层实现"></a>RunLoop 的底层实现</h2><p>从上面代码可以看到，RunLoop 的核心是基于 mach port 的，其进入休眠时调用的函数是 mach_msg()。为了解释这个逻辑，下面稍微介绍一下 OSX/iOS 的系统架构。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/904629-aefecc5007b9e4f6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="1128643-20170322100431846-467650130.png"></p>
<p>其中，在硬件层上面的三个组成部分：Mach、BSD、IOKit (还包括一些上面没标注的内容)，共同组成了 XNU 内核。</p>
<p>XNU 内核的内环被称作 Mach，其作为一个微内核，仅提供了诸如处理器调度、IPC (进程间通信)等非常少量的基础服务。</p>
<p>BSD 层可以看作围绕 Mach 层的一个外环，其提供了诸如进程管理、文件系统和网络等功能。</p>
<p>IOKit 层是为设备驱动提供了一个面向对象(C++)的一个框架。</p>
<p>Mach 本身提供的 API 非常有限，而且苹果也不鼓励使用 Mach 的 API，但是这些API非常基础，如果没有这些API的话，其他任何工作都无法实施。在 Mach 中，所有的东西都是通过自己的对象实现的，进程、线程和虚拟内存都被称为”对象”。和其他架构不同， Mach 的对象间不能直接调用，只能通过消息传递的方式实现对象间的通信。”消息”是 Mach 中最基础的概念，消息在两个端口 (port) 之间传递，这就是 Mach 的 IPC (进程间通信) 的核心。</p>
<p>Mach 的消息定义是在头文件的，很简单：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">mach_msg_return_t mach_msg(</div><div class="line">mach_msg_header_t *msg,</div><div class="line">mach_msg_option_t option,</div><div class="line">mach_msg_size_t send_size,</div><div class="line">mach_msg_size_t rcv_size,</div><div class="line">mach_port_name_t rcv_name,</div><div class="line">mach_msg_timeout_t timeout,</div><div class="line">mach_port_name_t notify);</div></pre></td></tr></table></figure></p>
<p>为了实现消息的发送和接收，mach_msg() 函数实际上是调用了一个 Mach 陷阱 (trap)，即函数mach_msg_trap()，陷阱这个概念在 Mach 中等同于系统调用。当你在用户态调用 mach_msg_trap() 时会触发陷阱机制，切换到内核态；内核态中内核实现的 mach_msg() 函数会完成实际的工作，如下图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/904629-ff633a9e5ec869b4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="1128643-20170322100539002-1257723842.png"><br>这些概念可以参考维基百科: <a href="http://en.wikipedia.org/wiki/System_call" target="_blank" rel="external">System_call</a>、<a href="http://en.wikipedia.org/wiki/Trap_(computing" target="_blank" rel="external">Trap_(computing)</a>)。<br>RunLoop 的核心就是一个 mach_msg() (见上面代码的第7步)，RunLoop 调用这个函数去接收消息，如果没有别人发送 port 消息过来，内核会将线程置于等待状态。例如你在模拟器里跑起一个 iOS 的 App，然后在 App 静止时点击暂停，你会看到主线程调用栈是停留在 mach_msg_trap() 这个地方。<br>关于具体的如何利用 mach port 发送信息，可以看看 <a href="http://nshipster.com/inter-process-communication/" target="_blank" rel="external">NSHipster 这一篇文章</a>，或者<a href="http://segmentfault.com/a/1190000002400329" target="_blank" rel="external">这里</a>的中文翻译 。<br>关于Mach的历史可以看看这篇很有趣的文章：<a href="http://www.programmer.com.cn/8121/" target="_blank" rel="external">Mac OS X 背后的故事（三）Mach 之父 Avie Tevanian</a>。</p>
<h2 id="苹果用RunLoop-实现的功能"><a href="#苹果用RunLoop-实现的功能" class="headerlink" title="苹果用RunLoop 实现的功能"></a>苹果用RunLoop 实现的功能</h2><p>首先我们可以看一下 App 启动后 RunLoop 的状态：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">CFRunLoop &#123;</div><div class="line">current mode = kCFRunLoopDefaultMode</div><div class="line">common modes = &#123;</div><div class="line">UITrackingRunLoopMode</div><div class="line">kCFRunLoopDefaultMode</div><div class="line">&#125;</div><div class="line"></div><div class="line">common mode items = &#123;</div><div class="line"></div><div class="line">// source0 (manual)</div><div class="line">CFRunLoopSource &#123;order =-1, &#123;</div><div class="line">callout = _UIApplicationHandleEventQueue&#125;&#125;</div><div class="line">CFRunLoopSource &#123;order =-1, &#123;</div><div class="line">callout = PurpleEventSignalCallback &#125;&#125;</div><div class="line">CFRunLoopSource &#123;order = 0, &#123;</div><div class="line">callout = FBSSerialQueueRunLoopSourceHandler&#125;&#125;</div><div class="line"></div><div class="line">// source1 (mach port)</div><div class="line">CFRunLoopSource &#123;order = 0,  &#123;port = 17923&#125;&#125;</div><div class="line">CFRunLoopSource &#123;order = 0,  &#123;port = 12039&#125;&#125;</div><div class="line">CFRunLoopSource &#123;order = 0,  &#123;port = 16647&#125;&#125;</div><div class="line">CFRunLoopSource &#123;order =-1, &#123;</div><div class="line">callout = PurpleEventCallback&#125;&#125;</div><div class="line">CFRunLoopSource &#123;order = 0, &#123;port = 2407,</div><div class="line">callout = _ZL20notify_port_callbackP12__CFMachPortPvlS1_&#125;&#125;</div><div class="line">CFRunLoopSource &#123;order = 0, &#123;port = 1c03,</div><div class="line">callout = __IOHIDEventSystemClientAvailabilityCallback&#125;&#125;</div><div class="line">CFRunLoopSource &#123;order = 0, &#123;port = 1b03,</div><div class="line">callout = __IOHIDEventSystemClientQueueCallback&#125;&#125;</div><div class="line">CFRunLoopSource &#123;order = 1, &#123;port = 1903,</div><div class="line">callout = __IOMIGMachPortPortCallback&#125;&#125;</div><div class="line"></div><div class="line">// Ovserver</div><div class="line">CFRunLoopObserver &#123;order = -2147483647, activities = 0x1, // Entry</div><div class="line">callout = _wrapRunLoopWithAutoreleasePoolHandler&#125;</div><div class="line">CFRunLoopObserver &#123;order = 0, activities = 0x20,          // BeforeWaiting</div><div class="line">callout = _UIGestureRecognizerUpdateObserver&#125;</div><div class="line">CFRunLoopObserver &#123;order = 1999000, activities = 0xa0,    // BeforeWaiting | Exit</div><div class="line">callout = _afterCACommitHandler&#125;</div><div class="line">CFRunLoopObserver &#123;order = 2000000, activities = 0xa0,    // BeforeWaiting | Exit</div><div class="line">callout = _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv&#125;</div><div class="line">CFRunLoopObserver &#123;order = 2147483647, activities = 0xa0, // BeforeWaiting | Exit</div><div class="line">callout = _wrapRunLoopWithAutoreleasePoolHandler&#125;</div><div class="line"></div><div class="line">// Timer</div><div class="line">CFRunLoopTimer &#123;firing = No, interval = 3.1536e+09, tolerance = 0,</div><div class="line">next fire date = 453098071 (-4421.76019 @ 96223387169499),</div><div class="line">callout = _ZN2CAL14timer_callbackEP16__CFRunLoopTimerPv (QuartzCore.framework)&#125;</div><div class="line">&#125;,</div><div class="line"></div><div class="line">modes ＝ &#123;</div><div class="line">CFRunLoopMode  &#123;</div><div class="line">sources0 =  &#123; /* same as <span class="string">'common mode items'</span> */ &#125;,</div><div class="line">sources1 =  &#123; /* same as <span class="string">'common mode items'</span> */ &#125;,</div><div class="line">observers = &#123; /* same as <span class="string">'common mode items'</span> */ &#125;,</div><div class="line">timers =    &#123; /* same as <span class="string">'common mode items'</span> */ &#125;,</div><div class="line">&#125;,</div><div class="line"></div><div class="line">CFRunLoopMode  &#123;</div><div class="line">sources0 =  &#123; /* same as <span class="string">'common mode items'</span> */ &#125;,</div><div class="line">sources1 =  &#123; /* same as <span class="string">'common mode items'</span> */ &#125;,</div><div class="line">observers = &#123; /* same as <span class="string">'common mode items'</span> */ &#125;,</div><div class="line">timers =    &#123; /* same as <span class="string">'common mode items'</span> */ &#125;,</div><div class="line">&#125;,</div><div class="line"></div><div class="line">CFRunLoopMode  &#123;</div><div class="line">sources0 = &#123;</div><div class="line">CFRunLoopSource &#123;order = 0, &#123;</div><div class="line">callout = FBSSerialQueueRunLoopSourceHandler&#125;&#125;</div><div class="line">&#125;,</div><div class="line">sources1 = (null),</div><div class="line">observers = &#123;</div><div class="line">CFRunLoopObserver &gt;&#123;activities = 0xa0, order = 2000000,</div><div class="line">callout = _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv&#125;</div><div class="line">)&#125;,</div><div class="line">timers = (null),</div><div class="line">&#125;,</div><div class="line"></div><div class="line">CFRunLoopMode  &#123;</div><div class="line">sources0 = &#123;</div><div class="line">CFRunLoopSource &#123;order = -1, &#123;</div><div class="line">callout = PurpleEventSignalCallback&#125;&#125;</div><div class="line">&#125;,</div><div class="line">sources1 = &#123;</div><div class="line">CFRunLoopSource &#123;order = -1, &#123;</div><div class="line">callout = PurpleEventCallback&#125;&#125;</div><div class="line">&#125;,</div><div class="line">observers = (null),</div><div class="line">timers = (null),</div><div class="line">&#125;,</div><div class="line"></div><div class="line">CFRunLoopMode  &#123;</div><div class="line">sources0 = (null),</div><div class="line">sources1 = (null),</div><div class="line">observers = (null),</div><div class="line">timers = (null),</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，系统默认注册了5个Mode:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">1. kCFRunLoopDefaultMode: App的默认 Mode，通常主线程是在这个 Mode 下运行的。</div><div class="line"></div><div class="line">2. UITrackingRunLoopMode: 界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 Mode 影响。</div><div class="line"></div><div class="line">3. UIInitializationRunLoopMode: 在刚启动 App 时第进入的第一个 Mode，启动完成后就不再使用。</div><div class="line"></div><div class="line">4: GSEventReceiveRunLoopMode: 接受系统事件的内部 Mode，通常用不到。</div><div class="line"></div><div class="line">5: kCFRunLoopCommonModes: 这是一个占位的 Mode，没有实际作用。</div><div class="line"></div><div class="line">你可以在这里看到更多的苹果内部的 Mode，但那些 Mode 在开发中就很难遇到了。</div></pre></td></tr></table></figure></p>
<p>当 RunLoop 进行回调时，一般都是通过一个很长的函数调用出去 (call out), 当你在你的代码中下断点调试时，通常能在调用栈上看到这些函数。下面是这几个函数的整理版本，如果你在调用栈中看到这些长函数名，在这里查找一下就能定位到具体的调用地点了：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">/// 1. 通知Observers，即将进入RunLoop</div><div class="line">/// 此处有Observer会创建AutoreleasePool: _objc_autoreleasePoolPush();</div><div class="line">__CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopEntry);</div><div class="line"><span class="keyword">do</span> &#123;</div><div class="line"></div><div class="line">/// 2. 通知 Observers: 即将触发 Timer 回调。</div><div class="line">__CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopBeforeTimers);</div><div class="line">/// 3. 通知 Observers: 即将触发 Source (非基于port的,Source0) 回调。</div><div class="line">__CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopBeforeSources);</div><div class="line">__CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__(block);</div><div class="line"></div><div class="line">/// 4. 触发 Source0 (非基于port的) 回调。</div><div class="line">__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__(source0);</div><div class="line">__CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__(block);</div><div class="line"></div><div class="line">/// 6. 通知Observers，即将进入休眠</div><div class="line">/// 此处有Observer释放并新建AutoreleasePool: _objc_autoreleasePoolPop(); _objc_autoreleasePoolPush();</div><div class="line">__CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopBeforeWaiting);</div><div class="line"></div><div class="line">/// 7. sleep to <span class="built_in">wait</span> msg.</div><div class="line">mach_msg() -&gt; mach_msg_trap();</div><div class="line"></div><div class="line"></div><div class="line">/// 8. 通知Observers，线程被唤醒</div><div class="line">__CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopAfterWaiting);</div><div class="line"></div><div class="line">/// 9. 如果是被Timer唤醒的，回调Timer</div><div class="line">__CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__(timer);</div><div class="line"></div><div class="line">/// 9. 如果是被dispatch唤醒的，执行所有调用 dispatch_async 等方法放入main queue 的 block</div><div class="line">__CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(dispatched_block);</div><div class="line"></div><div class="line">/// 9. 如果如果Runloop是被 Source1 (基于port的) 的事件唤醒了，处理这个事件</div><div class="line">__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION__(source1);</div><div class="line"></div><div class="line"></div><div class="line">&#125; <span class="keyword">while</span> (...);</div><div class="line"></div><div class="line">/// 10. 通知Observers，即将退出RunLoop</div><div class="line">/// 此处有Observer释放AutoreleasePool: _objc_autoreleasePoolPop();</div><div class="line">__CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopExit);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="AutoreleasePool"><a href="#AutoreleasePool" class="headerlink" title="AutoreleasePool"></a>AutoreleasePool</h2><p>App启动后，苹果在主线程 RunLoop 里注册了两个 Observer，其回调都是 _wrapRunLoopWithAutoreleasePoolHandler()。</p>
<p>第一个 Observer 监视的事件是 Entry(即将进入Loop)，其回调内会调用 _objc_autoreleasePoolPush() 创建自动释放池。其 order 是-2147483647，优先级最高，保证创建释放池发生在其他所有回调之前。</p>
<p>第二个 Observer 监视了两个事件： BeforeWaiting(准备进入休眠) 时调用_objc_autoreleasePoolPop() 和 _objc_autoreleasePoolPush() 释放旧的池并创建新池；Exit(即将退出Loop) 时调用 _objc_autoreleasePoolPop() 来释放自动释放池。这个 Observer 的 order 是 2147483647，优先级最低，保证其释放池子发生在其他所有回调之后。</p>
<p>在主线程执行的代码，通常是写在诸如事件回调、Timer回调内的。这些回调会被 RunLoop 创建好的 AutoreleasePool 环绕着，所以不会出现内存泄漏，开发者也不必显示创建 Pool 了。</p>
<h3 id="事件响应"><a href="#事件响应" class="headerlink" title="事件响应"></a>事件响应</h3><p>苹果注册了一个 Source1 (基于 mach port 的) 用来接收系统事件，其回调函数为 __IOHIDEventSystemClientQueueCallback()。<br>当一个硬件事件(触摸/锁屏/摇晃等)发生后，首先由 IOKit.framework 生成一个 IOHIDEvent 事件并由 SpringBoard 接收。这个过程的详细情况可以参考<a href="http://iphonedevwiki.net/index.php/IOHIDFamily" target="_blank" rel="external">这里</a>。SpringBoard 只接收按键(锁屏/静音等)，触摸，加速，接近传感器等几种 Event，随后用 mach port 转发给需要的App进程。随后苹果注册的那个 Source1 就会触发回调，并调用 _UIApplicationHandleEventQueue() 进行应用内部的分发。<br>_UIApplicationHandleEventQueue() 会把 IOHIDEvent 处理并包装成 UIEvent 进行处理或分发，其中包括识别 UIGesture/处理屏幕旋转/发送给 UIWindow 等。通常事件比如 UIButton 点击、touchesBegin/Move/End/Cancel 事件都是在这个回调中完成的。</p>
<h3 id="手势识别"><a href="#手势识别" class="headerlink" title="手势识别"></a>手势识别</h3><p>当上面的 _UIApplicationHandleEventQueue() 识别了一个手势时，其首先会调用 Cancel 将当前的 touchesBegin/Move/End 系列回调打断。随后系统将对应的 UIGestureRecognizer 标记为待处理。</p>
<p>苹果注册了一个 Observer 监测 BeforeWaiting (Loop即将进入休眠) 事件，这个Observer的回调函数是 _UIGestureRecognizerUpdateObserver()，其内部会获取所有刚被标记为待处理的 GestureRecognizer，并执行GestureRecognizer的回调。</p>
<p>当有 UIGestureRecognizer 的变化(创建/销毁/状态改变)时，这个回调都会进行相应处理。</p>
<h3 id="界面更新"><a href="#界面更新" class="headerlink" title="界面更新"></a>界面更新</h3><p>当在操作 UI 时，比如改变了 Frame、更新了 UIView/CALayer 的层次时，或者手动调用了 UIView/CALayer 的 setNeedsLayout/setNeedsDisplay方法后，这个 UIView/CALayer 就被标记为待处理，并被提交到一个全局的容器去。</p>
<p>苹果注册了一个 Observer 监听 BeforeWaiting(即将进入休眠) 和 Exit (即将退出Loop) 事件，回调去执行一个很长的函数：</p>
<p>_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()。这个函数里会遍历所有待处理的 UIView/CAlayer 以执行实际的绘制和调整，并更新 UI 界面。</p>
<p>这个函数内部的调用栈大概是这样的：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()</div><div class="line">QuartzCore:CA::Transaction::observer_callback:</div><div class="line">CA::Transaction::commit();</div><div class="line">CA::Context::commit_transaction();</div><div class="line">CA::Layer::layout_and_display_if_needed();</div><div class="line">CA::Layer::layout_if_needed();</div><div class="line">[CALayer layoutSublayers];</div><div class="line">[UIView layoutSubviews];</div><div class="line">CA::Layer::display_if_needed();</div><div class="line">[CALayer display];</div><div class="line">[UIView drawRect];</div></pre></td></tr></table></figure>
<h2 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h2><p>NSTimer 其实就是 CFRunLoopTimerRef，他们之间是 toll-free bridged 的。一个 NSTimer 注册到 RunLoop 后，RunLoop 会为其重复的时间点注册好事件。例如 10:00, 10:10, 10:20 这几个时间点。RunLoop为了节省资源，并不会在非常准确的时间点回调这个Timer。Timer 有个属性叫做 Tolerance (宽容度)，标示了当时间点到后，容许有多少最大误差。</p>
<p>如果某个时间点被错过了，例如执行了一个很长的任务，则那个时间点的回调也会跳过去，不会延后执行。就比如等公交，如果 10:10 时我忙着玩手机错过了那个点的公交，那我只能等 10:20 这一趟了。</p>
<p>CADisplayLink 是一个和屏幕刷新率一致的定时器（但实际实现原理更复杂，和 NSTimer 并不一样，其内部实际是操作了一个 Source）。如果在两次屏幕刷新之间执行了一个长任务，那其中就会有一帧被跳过去（和 NSTimer 相似），造成界面卡顿的感觉。在快速滑动TableView时，即使一帧的卡顿也会让用户有所察觉。Facebook 开源的 AsyncDisplayLink 就是为了解决界面卡顿的问题，其内部也用到了 RunLoop，这个稍后我会再单独写一页博客来分析。</p>
<h3 id="PerformSelecter"><a href="#PerformSelecter" class="headerlink" title="PerformSelecter"></a>PerformSelecter</h3><p>当调用 NSObject 的 performSelecter:afterDelay: 后，实际上其内部会创建一个 Timer 并添加到当前线程的 RunLoop 中。所以如果当前线程没有 RunLoop，则这个方法会失效。</p>
<p>当调用 performSelector:onThread: 时，实际上其会创建一个 Timer 加到对应的线程去，同样的，如果对应线程没有 RunLoop 该方法也会失效。</p>
<h3 id="关于GCD"><a href="#关于GCD" class="headerlink" title="关于GCD"></a>关于GCD</h3><p>实际上 RunLoop 底层也会用到 GCD 的东西，比如 RunLoop 是用 dispatch_source_t 实现的 Timer。但同时 GCD 提供的某些接口也用到了 RunLoop， 例如 dispatch_async()。</p>
<p>当调用 dispatch_async(dispatch_get_main_queue(), block) 时，libDispatch 会向主线程的 RunLoop 发送消息，RunLoop会被唤醒，并从消息中取得这个 block，并在回调 <strong>CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE</strong>() 里执行这个 block。但这个逻辑仅限于 dispatch 到主线程，dispatch 到其他线程仍然是由 libDispatch 处理的。</p>
<h3 id="关于网络请求"><a href="#关于网络请求" class="headerlink" title="关于网络请求"></a>关于网络请求</h3><p>iOS 中，关于网络请求的接口自下至上有如下几层:</p>
<p>CFSocket<br>CFNetwork       -&gt;ASIHttpRequest<br>NSURLConnection -&gt;AFNetworking<br>NSURLSession    -&gt;AFNetworking2, Alamofire</p>
<p>CFSocket 是最底层的接口，只负责 socket 通信。</p>
<p>CFNetwork 是基于 CFSocket 等接口的上层封装，ASIHttpRequest 工作于这一层。</p>
<p>NSURLConnection 是基于 CFNetwork 的更高层的封装，提供面向对象的接口，AFNetworking 工作于这一层。</p>
<p>NSURLSession 是 iOS7 中新增的接口，表面上是和 NSURLConnection 并列的，但底层仍然用到了 NSURLConnection 的部分功能 (比如 com.apple.NSURLConnectionLoader 线程)，AFNetworking2 和 Alamofire 工作于这一层。</p>
<p>下面主要介绍下 NSURLConnection 的工作过程。</p>
<p>通常使用 NSURLConnection 时，你会传入一个 Delegate，当调用了 [connection start] 后，这个 Delegate 就会不停收到事件回调。实际上，start 这个函数的内部会会获取 CurrentRunLoop，然后在其中的 DefaultMode 添加了4个 Source0 (即需要手动触发的Source)。CFMultiplexerSource 是负责各种 Delegate 回调的，CFHTTPCookieStorage 是处理各种 Cookie 的。</p>
<p>当开始网络传输时，我们可以看到 NSURLConnection 创建了两个新线程：com.apple.NSURLConnectionLoader 和 com.apple.CFSocket.private。其中 CFSocket 线程是处理底层 socket 连接的。NSURLConnectionLoader 这个线程内部会使用 RunLoop 来接收底层 socket 的事件，并通过之前添加的 Source0 通知到上层的 Delegate。<br><img src="http://upload-images.jianshu.io/upload_images/904629-ce4c380a8b52460b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="1128643-20170322100709033-837944595.png"></p>
<p>NSURLConnectionLoader 中的 RunLoop 通过一些基于 mach port 的 Source 接收来自底层 CFSocket 的通知。当收到通知后，其会在合适的时机向 CFMultiplexerSource 等 Source0 发送通知，同时唤醒 Delegate 线程的 RunLoop 来让其处理这些通知。CFMultiplexerSource 会在 Delegate 线程的 RunLoop 对 Delegate 执行实际的回调。</p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/OC/" rel="tag"># OC</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/05/28/WKWebView/" rel="prev" title="WKWebView 和 WebViewJavascriptBridge">
                WKWebView 和 WebViewJavascriptBridge <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.png"
               alt="Pan'V" />
          <p class="site-author-name" itemprop="name">Pan'V</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">7</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">3</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">7</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/L-vinCent" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://www.jianshu.com/u/4a7b7da390e4" target="_blank" title="简书">
                  
                    <i class="fa fa-fw fa-laptop"></i>
                  
                  简书
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#RunLoop-的概念"><span class="nav-number">1.</span> <span class="nav-text">RunLoop 的概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RunLoop-与线程的关系"><span class="nav-number">2.</span> <span class="nav-text">RunLoop 与线程的关系</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RunLoop-对外的接口"><span class="nav-number">3.</span> <span class="nav-text">RunLoop 对外的接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RunLoop-的内部逻辑"><span class="nav-number">4.</span> <span class="nav-text">RunLoop 的内部逻辑</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RunLoop-的底层实现"><span class="nav-number">5.</span> <span class="nav-text">RunLoop 的底层实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#苹果用RunLoop-实现的功能"><span class="nav-number">6.</span> <span class="nav-text">苹果用RunLoop 实现的功能</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AutoreleasePool"><span class="nav-number">7.</span> <span class="nav-text">AutoreleasePool</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#事件响应"><span class="nav-number">7.1.</span> <span class="nav-text">事件响应</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#手势识别"><span class="nav-number">7.2.</span> <span class="nav-text">手势识别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#界面更新"><span class="nav-number">7.3.</span> <span class="nav-text">界面更新</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#定时器"><span class="nav-number">8.</span> <span class="nav-text">定时器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#PerformSelecter"><span class="nav-number">8.1.</span> <span class="nav-text">PerformSelecter</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#关于GCD"><span class="nav-number">8.2.</span> <span class="nav-text">关于GCD</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#关于网络请求"><span class="nav-number">8.3.</span> <span class="nav-text">关于网络请求</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
<div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Pan'V</span>
</div>


<div class="powered-by">
  努力工作,努力生活
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>

<div class="busuanzi-count" >
<span class="site-uv">
<i class="fa fa-user"></i>
<span id="busuanzi_container_site_pv">
访问量: <span id="busuanzi_value_site_pv"></span> 次  
</span>
</span>

<span class="site-pv">
<i class="fa fa-quora"></i>
<span id="busuanzi_container_site_uv">
访客数: <span id="busuanzi_value_site_uv"></span> 人
</span>
</span>
</div>





        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  

    
      <script id="dsq-count-scr" src="https://L-vinCent.disqus.com/count.js" async></script>
    

    
      <script type="text/javascript">
        var disqus_config = function () {
          this.page.url = 'https://l-vincent.github.io/2017/05/12/Runloop/';
          this.page.identifier = '2017/05/12/Runloop/';
          this.page.title = '深入理解RunLoop';
        };
        var d = document, s = d.createElement('script');
        s.src = 'https://L-vinCent.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      </script>
    

  




	





  





  








  





  

  

  

  

  

  

</body>
</html>
